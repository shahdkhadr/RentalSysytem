# JWT With RBAC

# Bootstrap Layer ( Directory )

## File Structure

![image.png](JWT%20With%20RBAC%20135f1472fabd80f99611ca2eb0248117/image.png)

## Codes

### **`RoleSeeder.java`**

```java
package com.jwt.rbac.bootstrap;

import com.jwt.rbac.entities.Role;
import com.jwt.rbac.entities.RoleEnum;
import com.jwt.rbac.repositories.RoleRepository;
import org.springframework.context.ApplicationListener;
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.stereotype.Component;

import java.util.*;

@Component
public class RoleSeeder implements ApplicationListener<ContextRefreshedEvent> {
    private final RoleRepository roleRepository;

    public RoleSeeder(RoleRepository roleRepository) {
        this.roleRepository = roleRepository;
    }

    @Override
    public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) {
        this.loadRoles();
    }

    private void loadRoles() {
        RoleEnum[] roleNames = new RoleEnum[] { RoleEnum.USER, RoleEnum.ADMIN, RoleEnum.SUPER_ADMIN };
        Map<RoleEnum, String> roleDescriptionMap = Map.of(
                RoleEnum.USER, "Default user role",
                RoleEnum.ADMIN, "Administrator role",
                RoleEnum.SUPER_ADMIN, "Super Administrator role"
        );

        Arrays.stream(roleNames).forEach((roleName) -> {
            Optional<Role> optionalRole = roleRepository.findByName(roleName);

            optionalRole.ifPresentOrElse(System.out::println, () -> {
                Role roleToCreate = Role.builder()
                        .name(roleName)
                        .description(roleDescriptionMap.get(roleName))
                        .build();

                roleRepository.save(roleToCreate);
            });
        });
    }
}
```

### **`AdminSeeder.java`**

```java
package com.jwt.rbac.bootstrap;

import com.jwt.rbac.dtos.RegisterUserDto;
import com.jwt.rbac.entities.Role;
import com.jwt.rbac.entities.RoleEnum;
import com.jwt.rbac.entities.User;
import com.jwt.rbac.repositories.RoleRepository;
import com.jwt.rbac.repositories.UserRepository;
import org.springframework.context.ApplicationListener;
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;

import java.util.Optional;

@Component
public class AdminSeeder implements ApplicationListener<ContextRefreshedEvent> {
    private final RoleRepository roleRepository;
    private final UserRepository userRepository;

    private final PasswordEncoder passwordEncoder;

    public AdminSeeder(
            RoleRepository roleRepository,
            UserRepository  userRepository,
            PasswordEncoder passwordEncoder
    ) {
        this.roleRepository = roleRepository;
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
    }

    @Override
    public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) {
        this.createSuperAdministrator();
    }

    private void createSuperAdministrator() {
        RegisterUserDto userDto = RegisterUserDto.builder()
                .fullName("Super Admin")
                .email("super.admin@email.com")
                .password("123456")
                .build();

        Optional<Role> optionalRole = roleRepository.findByName(RoleEnum.SUPER_ADMIN);
        Optional<User> optionalUser = userRepository.findByEmail(userDto.getEmail());

        if (optionalRole.isEmpty() || optionalUser.isPresent()) {
            return;
        }

        var user = new User()
                .setFullName(userDto.getFullName())
                .setEmail(userDto.getEmail())
                .setPassword(passwordEncoder.encode(userDto.getPassword()))
                .setRole(optionalRole.get());

        userRepository.save(user);
    }
}

```

## Objective

- This Layer is responsible for initialization essential application data or performing tasks upon application startup.
    
    للبيانات الاساسية في التطبيق Initialization وظيفة هاي اللير انها تهيّئ او تعمل 
    أو تنفيذ وظيفة معينة عند بدء تشغيل التطبيق
    
- The **RoleSeeder** & **AdminSeeder** components are designed to create initial data for **roles** and a **super adminstrator** user
- This setup is beneficial in a role-based access control (RBAC) system, where defining roles and a super admin account on startup ensures that core entities are present for application functionality and security.
    
    بنعمل السييدرز عشان نتأكد انو السوبر أدمن والرولز موجودين أول اشي بالبرنامج عشان وينتا ما انطلبو جوا البرنامج يكونو موجودين
    

### Code Explanation and Purpose

### 1. `RoleSeeder` Class

### Part 1

- اللي بدها تكون موجودة عندنا في السيستيم Roles عشان نعمل انيشيالايز لل
    
    ```java
    @Component
    public class RoleSeeder implements ApplicationListener<ContextRefreshedEvent> {
    ```
    
- **`@Component` →** This annotation mark the class as **Spring Component**, which automatically **detect & managed** by **Spring Container**.
- **`ApplicationListener<ContextRefreshedEvent>`** → Implements an event listener that triggers on the **`ContextRefreshedEvent` , which occurs when the application context is fully loaded and initialized**
    - ببساطة وظيفتها انها تنفذ كود بشكل تلقائي لما 
    أو Initialize ينعملله  ApplicationContextال
    ينعملله ريفريش ( الريفريش بصير لما 
    Beans ينعمل لوود لل
    وتكتمل العملية Dependency Injectionأو لما يعمل 
     )
    
    > This event is particularly helpful for scenarios where you need **to perform some setup or initialization tasks only once, right after the application context is ready.**
    > 
    - Ref.: [https://chatgpt.com/share/6729b5dc-ba4c-8013-a13d-11ac8e6dc6ee](https://chatgpt.com/share/6729b5dc-ba4c-8013-a13d-11ac8e6dc6ee)

### Part 2

```java
private final RoleRepository roleRepository;

public RoleSeeder(RoleRepository roleRepository) {
    this.roleRepository = roleRepository;
}
// Constructor Injection
```

### Part 3

```java
@Override
public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) {
    this.loadRoles();
}
```

- `onApplicationEvent`: This method is executed on the `ContextRefreshedEvent` and calls `loadRoles()` to initialize roles.
- The `onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent)` method will execute when the `ApplicationContext` has been initialized or refreshed. This typically happens:
    1. When the application context is initially loaded and the application is started.
    2. When there is a refresh of the application context, such as a configuration or bean refresh.
    3. After dependency injection is completed and all singleton beans are fully initialized.

### Part 4

```java
private void loadRoles() {
    RoleEnum[] roleNames = new RoleEnum[] { RoleEnum.USER, RoleEnum.ADMIN, RoleEnum.SUPER_ADMIN };
    Map<RoleEnum, String> roleDescriptionMap = Map.of(
            RoleEnum.USER, "Default user role",
            RoleEnum.ADMIN, "Administrator role",
            RoleEnum.SUPER_ADMIN, "Super Administrator role"
    );
    
    Arrays.stream(roleNames).forEach((roleName) -> {
    Optional<Role> optionalRole = roleRepository.findByName(roleName);

    optionalRole.ifPresentOrElse(System.out::println, () -> {
        Role roleToCreate = Role.builder()
                .name(roleName)
                .description(roleDescriptionMap.get(roleName))
                .build();

        roleRepository.save(roleToCreate);
    });
}); 
```

- `roleNames`: An array of roles to create, defined in an enum `RoleEnum`.
- `roleDescriptionMap`: A map storing descriptions for each role.
- The code streams through `roleNames` and attempts to retrieve each role from the repository.
- `ifPresentOrElse`: If the role exists, it prints it out (for debugging purposes). If the role is not found, it creates and saves a new `Role` entity with a name and description.
1. **`AdminSeeder`** Class The same idea

# Entity Layer

## **`LoginResponse.java`**

```java
package com.jwt.rbac.entities;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class LoginResponse {
    private String token;

    private long expiresIn;

}
```

## **`Role.java`**

```java
package com.jwt.rbac.entities;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.util.Date;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "roles")
@Entity
@Builder
public class Role {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(nullable = false)
    private Integer id;

    @Column(unique = true, nullable = false)
    @Enumerated(EnumType.STRING)
    private RoleEnum name;

    @Column(nullable = false)
    private String description;

    @CreationTimestamp
    @Column(updatable = false, name = "created_at")
    private Date createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private Date updatedAt;

    // Getters and setters here....
}
```

## **`RoleEnum.java`**

```java
package com.jwt.rbac.entities;

public enum RoleEnum {
    USER,
    ADMIN,
    SUPER_ADMIN
}
```

## **`User.java`**

### Code

```java
package com.jwt.rbac.entities;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.Date;
import java.util.List;

@Table(name = "users")
@Entity
@Builder
@Data
@AllArgsConstructor
@NoArgsConstructor
public class User implements UserDetails {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(nullable = false)
    private Integer id;

    @Column(nullable = false)
    private String fullName;

    @Column(unique = true, length = 100, nullable = false)
    private String email;

    @Column(nullable = false)
    private String password;

    @CreationTimestamp
    @Column(updatable = false, name = "created_at")
    private Date createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private Date updatedAt;

    @ManyToOne(cascade = CascadeType.REMOVE)
    @JoinColumn(name = "role_id", referencedColumnName = "id", nullable = false)
    private Role role;

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        SimpleGrantedAuthority authority = new SimpleGrantedAuthority("ROLE_" + role.getName().toString());

        return List.of(authority);
    }

    public String getPassword() {
        return password;
    }

    @Override
    public String getUsername() {
        return email;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return true;
    }

    public Integer getId() {
        return id;
    }

    public User setId(Integer id) {
        this.id = id;
        return this;
    }

    public String getFullName() {
        return fullName;
    }

    public User setFullName(String fullName) {
        this.fullName = fullName;
        return this;
    }

    public String getEmail() {
        return email;
    }

    public User setEmail(String email) {
        this.email = email;
        return this;
    }

    public User setPassword(String password) {
        this.password = password;
        return this;
    }

    public Date getCreatedAt() {
        return createdAt;
    }

    public User setCreatedAt(Date createdAt) {
        this.createdAt = createdAt;
        return this;
    }

    public Date getUpdatedAt() {
        return updatedAt;
    }

    public User setUpdatedAt(Date updatedAt) {
        this.updatedAt = updatedAt;
        return this;
    }

    public Role getRole() {
        return role;
    }

    public User setRole(Role role) {
        this.role = role;
        return this;
    }

    @Override
    public String toString() {
        return "User{" +
                "id=" + id +
                ", fullName='" + fullName + '\'' +
                ", email='" + email + '\'' +
                ", password='" + password + '\'' +
                ", createdAt=" + createdAt +
                ", updatedAt=" + updatedAt +
                '}';
    }
}
```

- **`User`** entity implements **`UserDetails`** from **Spring Security,** which **allowing it to work seamlessly with Spring’s authentication mechanisms**

### **Methods from `UserDetails`**

- **`getAuthorities` →** Returns a collection of **`GrantedAuthority`** objects based on the user’s role.
    - Here, it adds a prefix “ROLE_” ****to the role name, which is common in Spring Security for role-based access.
- **`getPassword` →** Returns the user’s password
- **`getUsername` →** Return the **user’s email**, which serves as the username in the system
- **`isAccountNonExpired`**, **`isAccountNonLocked`**, **`isCredentialNonExpired`**, **`isEnabled` →** These methods indicate **the status of the user account**, and all return **`true`** in this implementation, meaning the account is always **active**, **unlock** and **enabled**

# **DTO Layer**

## **`LoginUserDto.java`**

```java
package com.jwt.rbac.dtos;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder

public class LoginUserDto {
    private String email;

    private String password;

}
```

## **`RegisterUserDto.java`**

```java
package com.jwt.rbac.dtos;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor

public class RegisterUserDto {
    private String email;

    private String password;

    private String fullName;

}

```

# **Repository Layer**

## **`RoleRepository.java`**

```java
package com.jwt.rbac.repositories;

import com.jwt.rbac.entities.Role;
import com.jwt.rbac.entities.RoleEnum;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface RoleRepository extends CrudRepository<Role, Integer> {
    Optional<Role> findByName(RoleEnum name);
}
```

## **`UserRepository.java`**

```java
package com.jwt.rbac.repositories;

import com.jwt.rbac.entities.User;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UserRepository extends CrudRepository<User, Integer> {
    Optional<User> findByEmail(String email);
}
```

# Service Layer

## **`AuthenticationService.java`**

## **code**

```java
package com.jwt.rbac.services;

import com.jwt.rbac.dtos.LoginUserDto;
import com.jwt.rbac.dtos.RegisterUserDto;
import com.jwt.rbac.entities.Role;
import com.jwt.rbac.entities.RoleEnum;
import com.jwt.rbac.entities.User;
import com.jwt.rbac.repositories.RoleRepository;
import com.jwt.rbac.repositories.UserRepository;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import java.util.Optional;

@Service
public class AuthenticationService {
    private final UserRepository userRepository;

    private final PasswordEncoder passwordEncoder;

    private final AuthenticationManager authenticationManager;

    private final RoleRepository roleRepository;

    public AuthenticationService(
            UserRepository userRepository,
            AuthenticationManager authenticationManager,
            PasswordEncoder passwordEncoder,
            RoleRepository roleRepository
    ) {
        this.authenticationManager = authenticationManager;
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
        this.roleRepository = roleRepository;
    }

    public User signup(RegisterUserDto input) {
        Optional<Role> optionalRole = roleRepository.findByName(RoleEnum.USER);

        if (optionalRole.isEmpty()) {
            return null;
        }

        User user = User.builder()
                .fullName(input.getFullName())
                .email(input.getEmail())
                .password(passwordEncoder.encode(input.getPassword()))
                .role(optionalRole.get())
                .build();

        return userRepository.save(user);
    }

    public User authenticate(LoginUserDto input) {
        authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(
                        input.getEmail(),
                        input.getPassword()
                )
        );

        return userRepository.findByEmail(input.getEmail())
                .orElseThrow();
    }
}
```

## Constructor Injection

```java
public AuthenticationService(
        UserRepository userRepository,
        AuthenticationManager authenticationManager,
        PasswordEncoder passwordEncoder,
        RoleRepository roleRepository
) {
    this.authenticationManager = authenticationManager;
    this.userRepository = userRepository;
    this.passwordEncoder = passwordEncoder;
    this.roleRepository = roleRepository;
}

```

## Signup Method

```
public User signup(RegisterUserDto input) {
    Optional<Role> optionalRole = roleRepository.findByName(RoleEnum.USER);

    if (optionalRole.isEmpty()) {
        return null;
    }

    User user = User.builder()
            .fullName(input.getFullName())
            .email(input.getEmail())
            .password(passwordEncoder.encode(input.getPassword()))
            .role(optionalRole.get())
            .build();

    return userRepository.save(user);
}

```

## **Authenticate Method**

```java
public User authenticate(LoginUserDto input) {
    authenticationManager.authenticate(
            new UsernamePasswordAuthenticationToken(
                    input.getEmail(),
                    input.getPassword()
            )
    );

    return userRepository.findByEmail(input.getEmail())
            .orElseThrow();
}

```

- Middleware responsible for verifying user credentials and updating the security context

## **`JwtService.java`**

## **code**

```java
package com.jwt.rbac.services;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;

import java.security.Key;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

@Service
public class JwtService {
    @Value("${security.jwt.secret-key}")
    private String secretKey;

    @Value("${security.jwt.expiration-time}")
    private long jwtExpiration;

    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    public String generateToken(UserDetails userDetails) {
        return generateToken(new HashMap<>(), userDetails);
    }

    public String generateToken(Map<String, Object> extraClaims, UserDetails userDetails) {
        return buildToken(extraClaims, userDetails, jwtExpiration);
    }

    public long getExpirationTime() {
        return jwtExpiration;
    }

    private String buildToken(
            Map<String, Object> extraClaims,
            UserDetails userDetails,
            long expiration
    ) {
        return Jwts
                .builder()
                .setClaims(extraClaims)
                .setSubject(userDetails.getUsername())
                .setIssuedAt(new Date(System.currentTimeMillis()))
                .setExpiration(new Date(System.currentTimeMillis() + expiration))
                .signWith(getSignInKey(), SignatureAlgorithm.HS256)
                .compact();
    }

    public boolean isTokenValid(String token, UserDetails userDetails) {
        final String username = extractUsername(token);
        return (username.equals(userDetails.getUsername())) && !isTokenExpired(token);
    }

    private boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    private Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    private Claims extractAllClaims(String token) {
        return Jwts
                .parserBuilder()
                .setSigningKey(getSignInKey())
                .build()
                .parseClaimsJws(token)
                .getBody();
    }

    private Key getSignInKey() {
        byte[] keyBytes = Decoders.BASE64.decode(secretKey);
        return Keys.hmacShaKeyFor(keyBytes);
    }
}

```

## Claims

- Is part of the Security Framework that deals with user authentication & authorization, specifically in relation to JSON Web Tokens( JWT )

## **Purpose of the Claims Class**

- Claims class is used to represent a set of claims that can be included in a JWT .
- Claims are statements about an entity( as User ) and Additional Meta Data.
- The claims can include various types of information, such as
    
    ### Registered claims
    
    - These are predefined claims that are not mandatory but recommended, Examples include
        - **`iss`** ( issuer ): The entity that issued the token
        - **`sub`** ( subject ): The subject of the token ( the user )
        - **`aud`** ( audience ): The recipient for whom the token is intended
        - **`exp`** ( expiration time ): The time after which the token is no longer valid.
        - **`nbf`** ( not before ): The time before which the token should not be accepted. الوقت الذي يجب ألا يتم قبول الرمز قبله
        - **`iat`** ( issued at ): The time at which the token was issued
            - ( التوكين ) الوقت الذي تم فيه إصدار الرمز
    
    ### **Public claims**
    
    - These are claims that can be defined by anyone and should be registered to avoid collisions.
    
    هذه ادعاءات يمكن تعريفها من قبل أي شخص ويجب تسجيلها لتجنب التعارضات.
    
    ### **Private claims**
    
    These are custom claims created to share information between parties that agree on using them.
    
    هذه مطالبات مخصصة تم إنشاؤها لمشاركة المعلومات بين الأطراف التي توافق على استخدامها.
    

## Use Cases

1. **User Authentication**: When a user logs in, a JWT is created, and the `Claims` class can hold user-specific information such as user ID, roles, and permissions. This JWT can be sent back to the client, which includes these claims for subsequent requests to authenticate the user.
2. **Authorization**: Claims can contain role-based information that determines what resources a user can access. For example, if the claim includes a user role of `admin`, the application can allow access to admin-specific routes or functionalities.
3. **Session Management**: Claims can store session-related information such as the user’s last activity time or the duration for which the session is valid. This allows applications to manage user sessions effectively.
4. **Data Sharing**: Claims can be used to share specific information between different services or microservices in a distributed architecture. For example, a claim could include user preferences or settings that other services can utilize.
5. **Custom Claims**: Developers can define their own claims to include specific application-related data that might be relevant for processing requests or providing personalized user experiences.

### Part 1

```java
   public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }
    // This method extracts the username ( or subject ) from the JWT
    // String token: The JWT from which the username is to be extracted.
    
    // Functionality:

			 // It calls the extractClaim method, passing the token and a method reference Claims::getSubject.
       // Claims::getSubject is a functional interface that retrieves the sub (subject) claim from the Claims object, which usually contains the username or user ID.
       // Return Value:

       // It returns the username or subject as a String.
private Claims extractAllClaims(String token) {
        return Jwts
                .parserBuilder()
                .setSigningKey(getSignInKey())
                .build()
                .parseClaimsJws(token)
                .getBody();
    }
```

---

```java
public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }
```

### Explain

### Purpose

- This method is a generic method used to extract any specific claim from the JWT using a `Function` that defines how to retrieve the desired claim.

### Details

- **Parameters**:
    - `String token`: The JWT from which to extract the claim.
    - `Function<Claims, T> claimsResolver`: A function that takes a `Claims` object and returns the desired claim type `T`.

### **Functionality**

- It first calls the `extractAllClaims` method to get all the claims from the token.
- It then applies the `claimsResolver` function to the `Claims` object to extract the specific claim requested.

### **Return Value**

- Returns the extracted claim as type `T`, which can be any type depending on the claim being resolved.

---

```java
private Claims extractAllClaims(String token) {
    return Jwts
            .parserBuilder()
            .setSigningKey(getSignInKey())
            .build()
            .parseClaimsJws(token)
            .getBody();
}
```

### Explain

### Purpose

- This method extracts all claims from the provided JWT.

### Details

- **Parameters**:
    - `String token`: The JWT from which to extract claims.
- **Functionality**
    - It utilizes the `Jwts.parserBuilder()` to create a JWT parser.
    - It sets the signing key using a method called `getSignInKey()`, which typically retrieves the key used to sign the JWT.
    - The `build()` method finalizes the parser configuration.
    - The `parseClaimsJws(token)` method is then called, which verifies the token's signature and parses its claims.
    - Finally, `getBody()` retrieves the claims from the parsed JWT.
- **Return Value**
    - Returns a `Claims` object containing all the claims in the JWT, which can then be accessed using various methods like `getSubject()`, `getExpiration()`, etc.

## **`UserService.java`**

```java
package com.jwt.rbac.services;

import com.jwt.rbac.dtos.RegisterUserDto;
import com.jwt.rbac.entities.Role;
import com.jwt.rbac.entities.RoleEnum;
import com.jwt.rbac.entities.User;
import com.jwt.rbac.repositories.RoleRepository;
import com.jwt.rbac.repositories.UserRepository;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

@Service
public class UserService {
    private final UserRepository userRepository;
    private final RoleRepository roleRepository;
    private final PasswordEncoder passwordEncoder;

    public UserService(UserRepository userRepository, RoleRepository roleRepository, PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.roleRepository = roleRepository;
        this.passwordEncoder = passwordEncoder;

    }

    public List<User> allUsers() {
        List<User> users = new ArrayList<>();

        userRepository.findAll().forEach(users::add);

        return users;
    }

    public User createAdministrator(RegisterUserDto input) {
        Optional<Role> optionalRole = roleRepository.findByName(RoleEnum.ADMIN);

        if (optionalRole.isEmpty()) {
            return null;
        }

        var user = User.builder()
                .fullName(input.getFullName())
                .email(input.getEmail())
                .password(passwordEncoder.encode(input.getPassword()))
                .role(optionalRole.get())
                .build();

        return userRepository.save(user);
    }
}
```

# **Config Layer**

## **`ApplicationConfiguration.java`**

### Purpose

- The class serves as a configuration class for setting up
    - **user authentication**
    - and **password encoding** in a Spring Security context.

## Objectives

- **UserDetailsService Bean**:
    - The `userDetailsService()` method defines a `UserDetailsService` bean that retrieves user details by email from the `UserRepository`. This service is crucial for authenticating users and loading user-specific data.
    - It throws a `UsernameNotFoundException` if the user is not found, ensuring that the authentication process can appropriately handle this case.
- **BCryptPasswordEncoder Bean**:
    - The `passwordEncoder()` method returns a `BCryptPasswordEncoder` instance used for hashing passwords. This is essential for securely storing user passwords and verifying them during the login process.
- **AuthenticationManager Bean**:
    - The `authenticationManager()` method retrieves the `AuthenticationManager` from the provided `AuthenticationConfiguration`. This manager is responsible for authenticating users based on the credentials provided.
- **AuthenticationProvider Bean**:
    - The `authenticationProvider()` method configures a `DaoAuthenticationProvider`, which integrates the `UserDetailsService` and `PasswordEncoder`. This provider authenticates users by verifying their credentials against the database.

## **`JwtAuthenticationFilter.java`**

## Purpose

- This class acts as
    - a filter in the Spring Security filter chain,
- responsible for
    - validating JWTs
    - and setting the authentication context for requests.

## Objectives

- **Filter Logic**:
    - The `doFilterInternal` method overrides the filter's logic to intercept requests. It checks for the presence of an `Authorization` header and verifies whether it starts with "Bearer ".
- **Token Validation**:
    - If a valid JWT is found, the filter extracts the username from the token using the `JwtService`. If the user is not already authenticated, it attempts to load the user's details from the `UserDetailsService`.
- **Setting Authentication Context**:
    - If the user details are successfully retrieved and the token is valid, it creates an `UsernamePasswordAuthenticationToken`, populating the security context with the authenticated user's information and roles.
- **Exception Handling**:
    - If any exception occurs during the processing, it uses the `HandlerExceptionResolver` to handle the exception gracefully, ensuring that the application can respond to errors appropriately.

## **`SecurityConfiguration.java`**

## Purpose

- **This class configures Spring Security for the application**, establishing
    - security filters,
    - authorization rules,
    - and CORS settings.

## Objectives

- **Security Filter Chain**:
    - The `securityFilterChain()` method configures HTTP security, disabling CSRF protection, specifying authorization rules, and establishing stateless session management. It also adds the `JwtAuthenticationFilter` to the filter chain before the `UsernamePasswordAuthenticationFilter`.
- **Authorization Rules**:
    - The authorization configuration allows unrestricted access to endpoints matching `/auth/**` while requiring authentication for all other requests.
- **CORS Configuration**:
    - The `corsConfigurationSource()` method defines CORS settings, specifying allowed origins, methods, and headers. This is crucial for enabling cross-origin requests from specific clients (in this case, `http://localhost:8005`).
- **Integration with AuthenticationProvider**:
    - The class utilizes the `AuthenticationProvider` to authenticate users based on the provided credentials, ensuring a secure authentication process.